--
-- multi function in join queries aims to test the function calls that are
-- used in joins.
--
-- These functions are supposed to be executed on the worker and to ensure
-- that we wrap those functions inside (SELECT * FROM fnc()) sub queries.
--
-- We do not yet support those functions that:
--  - return records
--  - return tables
--  - are user-defined and immutable
CREATE SCHEMA functions_in_joins;
SET search_path TO 'functions_in_joins';
SET citus.next_shard_id TO 2500000;
CREATE TABLE table1 (id int, data int);
SELECT create_distributed_table('table1','id');
 create_distributed_table 
--------------------------
 
(1 row)

INSERT INTO table1
SELECT x, x*x
from generate_series(1, 100) as f (x);
-- Verbose messages for observing the subqueries that wrapped function calls
SET client_min_messages TO DEBUG;
-- Check joins on a sequence
CREATE SEQUENCE numbers;
SELECT * FROM table1 JOIN nextval('numbers') n ON (id = n);
DEBUG:  Wrapping a function in a subquery
DEBUG:  generating subplan 2_1 for subquery SELECT n FROM nextval('functions_in_joins.numbers'::regclass) n(n)
DEBUG:  Plan 2 query after replacing subqueries and CTEs: SELECT table1.id, table1.data, n.n FROM (functions_in_joins.table1 JOIN (SELECT intermediate_result.n FROM read_intermediate_result('2_1'::text, 'binary'::citus_copy_format) intermediate_result(n bigint)) n ON ((table1.id OPERATOR(pg_catalog.=) n.n)))
 id | data | n 
----+------+---
  1 |    1 | 1
(1 row)

-- Check joins of a function that returns a single integer
CREATE FUNCTION add(integer, integer) RETURNS integer
AS 'SELECT $1 + $2;'
LANGUAGE SQL;
SELECT * FROM table1 JOIN add(3,5) sum ON (id = sum);
DEBUG:  Wrapping a function in a subquery
DEBUG:  generating subplan 3_1 for subquery SELECT sum FROM functions_in_joins.add(3, 5) sum(sum)
DEBUG:  Plan 3 query after replacing subqueries and CTEs: SELECT table1.id, table1.data, sum.sum FROM (functions_in_joins.table1 JOIN (SELECT intermediate_result.sum FROM read_intermediate_result('3_1'::text, 'binary'::citus_copy_format) intermediate_result(sum integer)) sum ON ((table1.id OPERATOR(pg_catalog.=) sum.sum)))
 id | data | sum 
----+------+-----
  8 |   64 |   8
(1 row)

-- Check join of plpgsql functions
-- a function returning a single integer
CREATE OR REPLACE FUNCTION increment(i integer) RETURNS integer AS $$
BEGIN
  RETURN i + 1;
END;
$$ LANGUAGE plpgsql;
SELECT * FROM table1 JOIN increment(2) val ON (id = val);
DEBUG:  Wrapping a function in a subquery
DEBUG:  generating subplan 4_1 for subquery SELECT val FROM functions_in_joins.increment(2) val(val)
DEBUG:  Plan 4 query after replacing subqueries and CTEs: SELECT table1.id, table1.data, val.val FROM (functions_in_joins.table1 JOIN (SELECT intermediate_result.val FROM read_intermediate_result('4_1'::text, 'binary'::citus_copy_format) intermediate_result(val integer)) val ON ((table1.id OPERATOR(pg_catalog.=) val.val)))
 id | data | val 
----+------+-----
  3 |    9 |   3
(1 row)

-- a function that returns a set of integers
CREATE OR REPLACE FUNCTION next_k_integers(IN first_value INTEGER,
                                           IN k INTEGER DEFAULT 3,
                                           OUT result INTEGER)
  RETURNS SETOF INTEGER AS $$
BEGIN
  RETURN QUERY SELECT x FROM generate_series(first_value, first_value+k-1) f(x);
END;
$$ LANGUAGE plpgsql;
SELECT *
FROM table1 JOIN next_k_integers(3,2) next_integers ON (id = next_integers.result)
ORDER BY id ASC;
DEBUG:  Wrapping a function in a subquery
DEBUG:  generating subplan 5_1 for subquery SELECT result FROM functions_in_joins.next_k_integers(3, 2) next_integers(result)
DEBUG:  Plan 5 query after replacing subqueries and CTEs: SELECT table1.id, table1.data, next_integers.result FROM (functions_in_joins.table1 JOIN (SELECT intermediate_result.result FROM read_intermediate_result('5_1'::text, 'binary'::citus_copy_format) intermediate_result(result integer)) next_integers ON ((table1.id OPERATOR(pg_catalog.=) next_integers.result))) ORDER BY table1.id
 id | data | result 
----+------+--------
  3 |    9 |      3
  4 |   16 |      4
(2 rows)

-- a stable function
CREATE OR REPLACE FUNCTION the_minimum_id()
  RETURNS INTEGER STABLE AS 'SELECT min(id) FROM table1' LANGUAGE SQL;
SELECT * FROM table1 JOIN the_minimum_id() min_id ON (id = min_id);
DEBUG:  Wrapping a function in a subquery
DEBUG:  generating subplan 6_1 for subquery SELECT min_id FROM functions_in_joins.the_minimum_id() min_id(min_id)
DEBUG:  Plan 6 query after replacing subqueries and CTEs: SELECT table1.id, table1.data, min_id.min_id FROM (functions_in_joins.table1 JOIN (SELECT intermediate_result.min_id FROM read_intermediate_result('6_1'::text, 'binary'::citus_copy_format) intermediate_result(min_id integer)) min_id ON ((table1.id OPERATOR(pg_catalog.=) min_id.min_id)))
 id | data | min_id 
----+------+--------
  1 |    1 |      1
(1 row)

-- a built-in immutable function
SELECT * FROM table1 JOIN abs(100) as hundred ON (id = hundred);
DEBUG:  Wrapping a function in a subquery
 id  | data  | hundred 
-----+-------+---------
 100 | 10000 |     100
(1 row)

-- function joins inside a CTE
WITH next_row_to_process AS (
    SELECT * FROM table1 JOIN nextval('numbers') n ON (id = n)
    )
SELECT *
FROM table1, next_row_to_process
WHERE table1.data <= next_row_to_process.data;
DEBUG:  generating subplan 9_1 for CTE next_row_to_process: SELECT table1.id, table1.data, n.n FROM (functions_in_joins.table1 JOIN nextval('functions_in_joins.numbers'::regclass) n(n) ON ((table1.id OPERATOR(pg_catalog.=) n.n)))
DEBUG:  Wrapping a function in a subquery
DEBUG:  generating subplan 10_1 for subquery SELECT n FROM nextval('functions_in_joins.numbers'::regclass) n(n)
DEBUG:  Plan 10 query after replacing subqueries and CTEs: SELECT table1.id, table1.data, n.n FROM (functions_in_joins.table1 JOIN (SELECT intermediate_result.n FROM read_intermediate_result('10_1'::text, 'binary'::citus_copy_format) intermediate_result(n bigint)) n ON ((table1.id OPERATOR(pg_catalog.=) n.n)))
DEBUG:  Plan 9 query after replacing subqueries and CTEs: SELECT table1.id, table1.data, next_row_to_process.id, next_row_to_process.data, next_row_to_process.n FROM functions_in_joins.table1, (SELECT intermediate_result.id, intermediate_result.data, intermediate_result.n FROM read_intermediate_result('9_1'::text, 'binary'::citus_copy_format) intermediate_result(id integer, data integer, n bigint)) next_row_to_process WHERE (table1.data OPERATOR(pg_catalog.<=) next_row_to_process.data)
 id | data | id | data | n 
----+------+----+------+---
  1 |    1 |  2 |    4 | 2
  2 |    4 |  2 |    4 | 2
(2 rows)

-- The following tests will fail as we do not support  all joins on
-- all kinds of functions
SET client_min_messages TO ERROR;
-- function joins in CTE results can create lateral joins that are not supported
SELECT public.raise_failed_execution($cmd$
WITH one_row AS (
    SELECT * FROM table1 WHERE id=52
    )
SELECT table1.id, table1.data
FROM one_row, table1, next_k_integers(one_row.id, 5) next_five_ids
WHERE table1.id = next_five_ids;
$cmd$);
ERROR:  Task failed to execute
CONTEXT:  PL/pgSQL function public.raise_failed_execution(text) line 6 at RAISE
-- a function returning table
CREATE FUNCTION get_two_column_table() RETURNS TABLE(x int,y int) AS
$cmd$
SELECT x, x+1 FROM generate_series(0,4) f(x)
$cmd$
LANGUAGE SQL;
SELECT public.raise_failed_execution($cmd$
SELECT * FROM table1 JOIN get_two_column_table() t2 ON (id = x)
$cmd$);
ERROR:  Task failed to execute
CONTEXT:  PL/pgSQL function public.raise_failed_execution(text) line 6 at RAISE
-- a function returning records
CREATE FUNCTION get_set_of_records() RETURNS SETOF RECORD AS $cmd$
SELECT x, x+1 FROM generate_series(0,4) f(x)
$cmd$
LANGUAGE SQL;
SELECT public.raise_failed_execution($cmd$
SELECT * FROM table1 JOIN get_set_of_records() AS t2(x int, y int) ON (id = x)
$cmd$);
ERROR:  Task failed to execute
CONTEXT:  PL/pgSQL function public.raise_failed_execution(text) line 6 at RAISE
-- a user-defined immutable function
CREATE OR REPLACE FUNCTION the_answer_to_life()
  RETURNS INTEGER IMMUTABLE AS 'SELECT 42' LANGUAGE SQL;
SELECT public.raise_failed_execution($cmd$
SELECT * FROM table1 JOIN the_answer_to_life() the_answer ON (id = the_answer)
$cmd$);
ERROR:  Task failed to execute
CONTEXT:  PL/pgSQL function public.raise_failed_execution(text) line 6 at RAISE
-- Multiple functions in an RTE
-- NOTE: Wrapping the functions in subqueries does not work as postgres does
-- not allow having a subquery after a ROWS FROM clause.
SELECT * FROM ROWS FROM (next_k_integers(5), next_k_integers(10)) AS f(a, b),
    table1 WHERE id = a;
ERROR:  could not find attribute 2 in subquery targetlist
-- WITH ORDINALITY clause forcing the result type to be RECORD/RECORDs
SELECT *
FROM table1
       JOIN next_k_integers(10,5) WITH ORDINALITY next_integers
         ON (id = next_integers.result)
ORDER BY id ASC;
ERROR:  could not find attribute 2 in subquery targetlist
RESET client_min_messages;
DROP SCHEMA functions_in_joins CASCADE;
NOTICE:  drop cascades to 9 other objects
DETAIL:  drop cascades to table table1
drop cascades to sequence numbers
drop cascades to function add(integer,integer)
drop cascades to function increment(integer)
drop cascades to function next_k_integers(integer,integer)
drop cascades to function the_minimum_id()
drop cascades to function get_two_column_table()
drop cascades to function get_set_of_records()
drop cascades to function the_answer_to_life()
SET search_path TO DEFAULT;
